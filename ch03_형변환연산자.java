public class ch03_형변환연산자 {
    // 3-7 형변환 연산자
    // 형 변환이란?
    // 변수나 상수 타입을 다른 타입으로 변환하는 것을 말함.
    // 바꾸는 방법 - 피연산자 앞에 (타입)적어주면됨 (타입)피연산자
    // ex) double d = 85.4; // 85.4가 저장됨
    // 인티저 타입에 85.4를 저장하고 싶음.
    // int socre = (int)d; // 더블을 인티저로 바꿔서 저장한다는 뜻임
    // 피연산자 타입인 d를 인티저 타입으로 바꾼다.
    // int socre = 85; score 값은 85가 되는 것임.
    // 85.4 값을 integer 타입으로 변환한거임

    // 3-7 형변환 연산자
    // int -> char -- (char)65 -> 'A'  유니코드 문자표에 의해서 이렇게 바뀜
    // char -> int -- (int)'A' -> 65 /// A가 65임
    // float -> int -- (int)1.6f --> 1 -- 인티저타입은 소숫점 저장 안됨 1만 저장.
    // int -> float -- (float)10 --> 10.0 -- 소숫점 됨.

    // 3-8 자동 형변환 --
    // why 형변환을 하는가?
    // 서로 다른 두 타입을 일치시키기 위해서임, 형변환 생략하면 컴파일러가 자동 형변환함.

    // float f = 1234; // int 타입을 float 타입 변수에 저장.
    // 좌는 플로트타입인데 우는 정수 타입이라고 근데 일치하지가 않잖아.
    // int 값은 플로트값 범위보다 적으니까 플로트 타입에 넣을 수 있음.
    // 따라서 문제가 없다.
    // float f = (float)1234; --- 이렇게하면 아무 문제가 없어.
    // float f = 1234; 이렇게 쓰면 자동형변환되어 바로 윗줄처럼 형변환함.
    // 컴파일러가 자동으로 형변환 시켜준다.

    // int i = 3.14f; /// 우쪽은 플로트 타입인데 int 값에 저장하려니까 저장이 안됨.
    // 3.14를 int로 저장하면 3이되는데
    // 우쪽에서 좌쪽으로 저장하려고 하면 에러가난다.
    // 큰값을 작은그릇에 담으려 하기 때문임.
    // 때문에 int i = (int)3.14f; // 괄호인트 형변환을 수동변환해줘서 에러없게 만들어줌.

    // 1. byte -> int
    // byte b = 10;
    // int i = b; // 생략가능
    // int는 4바이트  b; 는 1바이트 -- b쪽이 작은 값이라 자동변환됨.

    // 2. int -> byte
    // int i2 = 300;
    // byte b2 = (byte)i2; // 생략 안됨.
    // 우측이 더 큰데 좌측 더 작은 그릇에 담으려하니 값 손실 발생 할 수 있어.

    // 형변환 -- 서로 다른 두 타입을 일치시키기 위해서이다.

    // byte -> short -> int -> long -> float -> double
    //  1       2       4       8      4         8
    // 표현할 수 있는 값은 바이트에서 더블 쪽으로는 자동으로 형변환됨.

    // byte b = 100; 100은 int 타입임 4바이트
    // byte b = (-128 ~ 127 값임)
    // 인티저 타입인 100을 바이트 값에 넣음에도 불구하고 저장됨.
    // 이유는 인티저이지만 바이트타입의 범위안에 들어가기 때문이다.
    // 상단처럼 문장을 써도 문제가 없는 이유는 컴파일러가 자동으로 형변환을 하기 때문임
    // byte b = (byte)100; <- 컴파일러의 자동 변환.

    // 하지만
    // int i = 100;
    // byte b = i; // 에러남 위에는 비록 100이 int 타입이라도 byte 범위안에들어가 정상
    // 하지만 i는 문자이기 때문에 수동형변환을 해줘야지만 에러가 없다
    //  byte b = (byte)i; <-- 이것처럼 수동 변환해줘야해.


    // byte b = 1000; ///  에러남 -- 바이트 값을 초과했기 때문이다.
    // byte b = (byte)1000; // 정상임 하지만 값 손실 발생한다. -24 저장됨.
}
